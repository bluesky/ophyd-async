import collections.abc
import enum
from _typeshed import Incomplete
from typing import Callable, ClassVar, overload

Continuous: DurationDiscretization
Discrete: DurationDiscretization
Error: Result
ErrorExecutionTimeCalculation: Result
ErrorInvalidInput: Result
ErrorPositionalLimits: Result
ErrorSynchronizationCalculation: Result
Finished: Result
No: Synchronization
Phase: Synchronization
Position: ControlInterface
Time: Synchronization
TimeIfNecessary: Synchronization
Velocity: ControlInterface
Working: Result
__version__: str

class Bound:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def max(self): ...
    @property
    def min(self): ...
    @property
    def t_max(self): ...
    @property
    def t_min(self): ...

class BrakeProfile:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def a(self): ...
    @property
    def duration(self): ...
    @property
    def j(self): ...
    @property
    def p(self): ...
    @property
    def t(self): ...
    @property
    def v(self): ...

class ControlInterface(enum.Enum):
    __new__: ClassVar[Callable] = ...
    Position: ClassVar[ControlInterface] = ...
    Velocity: ClassVar[ControlInterface] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[object]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    _value_repr_: ClassVar[None] = ...
    __nb_enum__: ClassVar[PyCapsule] = ...

class DurationDiscretization(enum.Enum):
    __new__: ClassVar[Callable] = ...
    Continuous: ClassVar[DurationDiscretization] = ...
    Discrete: ClassVar[DurationDiscretization] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[object]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    _value_repr_: ClassVar[None] = ...
    __nb_enum__: ClassVar[PyCapsule] = ...

class InputParameter:
    control_interface: Incomplete
    current_acceleration: Incomplete
    current_position: Incomplete
    current_velocity: Incomplete
    duration_discretization: Incomplete
    enabled: Incomplete
    intermediate_positions: Incomplete
    interrupt_calculation_duration: Incomplete
    max_acceleration: Incomplete
    max_jerk: Incomplete
    max_position: Incomplete
    max_velocity: Incomplete
    min_acceleration: Incomplete
    min_position: Incomplete
    min_velocity: Incomplete
    minimum_duration: Incomplete
    per_dof_control_interface: Incomplete
    per_dof_synchronization: Incomplete
    per_section_max_acceleration: Incomplete
    per_section_max_jerk: Incomplete
    per_section_max_position: Incomplete
    per_section_max_velocity: Incomplete
    per_section_min_acceleration: Incomplete
    per_section_min_position: Incomplete
    per_section_min_velocity: Incomplete
    per_section_minimum_duration: Incomplete
    synchronization: Incomplete
    target_acceleration: Incomplete
    target_position: Incomplete
    target_velocity: Incomplete
    @overload
    def __init__(self, dofs: int) -> None: ...
    @overload
    def __init__(self, dofs: int, max_number_of_waypoints: int) -> None: ...
    def validate(self, check_current_state_within_limits: bool = ..., check_target_state_within_limits: bool = ...) -> bool: ...
    def __ne__(self, arg: InputParameter) -> bool: ...
    @property
    def degrees_of_freedom(self): ...

class OutputParameter:
    time: Incomplete
    @overload
    def __init__(self, dofs: int) -> None: ...
    @overload
    def __init__(self, dofs: int, max_number_of_waypoints: int) -> None: ...
    def pass_to_input(self, input: InputParameter) -> None: ...
    def __copy__(self) -> OutputParameter: ...
    @property
    def calculation_duration(self): ...
    @property
    def degrees_of_freedom(self): ...
    @property
    def did_section_change(self): ...
    @property
    def new_acceleration(self): ...
    @property
    def new_calculation(self): ...
    @property
    def new_position(self): ...
    @property
    def new_section(self): ...
    @property
    def new_velocity(self): ...
    @property
    def trajectory(self): ...
    @property
    def was_calculation_interrupted(self): ...

class Profile:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def a(self): ...
    @property
    def accel(self): ...
    @property
    def af(self): ...
    @property
    def brake(self): ...
    @property
    def control_signs(self): ...
    @property
    def direction(self): ...
    @property
    def j(self): ...
    @property
    def limits(self): ...
    @property
    def p(self): ...
    @property
    def pf(self): ...
    @property
    def t(self): ...
    @property
    def v(self): ...
    @property
    def vf(self): ...

class Result(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    Error: ClassVar[Result] = ...
    ErrorExecutionTimeCalculation: ClassVar[Result] = ...
    ErrorInvalidInput: ClassVar[Result] = ...
    ErrorPositionalLimits: ClassVar[Result] = ...
    ErrorSynchronizationCalculation: ClassVar[Result] = ...
    Finished: ClassVar[Result] = ...
    Working: ClassVar[Result] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    __nb_enum__: ClassVar[PyCapsule] = ...
    def __format__(self, *args, **kwargs) -> str: ...

class Ruckig:
    delta_time: Incomplete
    @overload
    def __init__(self, dofs: int) -> None: ...
    @overload
    def __init__(self, dofs: int, delta_time: float) -> None: ...
    @overload
    def __init__(self, dofs: int, delta_time: float, max_number_of_waypoints: int = ...) -> None: ...
    @overload
    def calculate(self, input: InputParameter, trajectory: Trajectory) -> Result: ...
    @overload
    def calculate(self, input: InputParameter, trajectory: Trajectory, was_interrupted: bool) -> Result: ...
    def filter_intermediate_positions(self, input: InputParameter, threshold_distance: collections.abc.Sequence[float]) -> list[list[float]]: ...
    def reset(self) -> None: ...
    def update(self, input: InputParameter, output: OutputParameter) -> Result: ...
    def validate_input(self, input: InputParameter, check_current_state_within_limits: bool = ..., check_target_state_within_limits: bool = ...) -> bool: ...
    @property
    def degrees_of_freedom(self): ...
    @property
    def max_number_of_waypoints(self): ...

class RuckigError(Exception): ...

class Synchronization(enum.Enum):
    __new__: ClassVar[Callable] = ...
    No: ClassVar[Synchronization] = ...
    Phase: ClassVar[Synchronization] = ...
    Time: ClassVar[Synchronization] = ...
    TimeIfNecessary: ClassVar[Synchronization] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[object]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    _value_repr_: ClassVar[None] = ...
    __nb_enum__: ClassVar[PyCapsule] = ...

class Trajectory:
    @overload
    def __init__(self, dofs: int) -> None: ...
    @overload
    def __init__(self, dofs: int, max_number_of_waypoints: int) -> None: ...
    def at_time(self, time: float, return_section: bool = ...) -> tuple: ...
    def get_first_time_at_position(self, dof: int, position: float, time_after: float = ...) -> float | None: ...
    @property
    def degrees_of_freedom(self): ...
    @property
    def duration(self): ...
    @property
    def independent_min_durations(self): ...
    @property
    def intermediate_durations(self): ...
    @property
    def position_extrema(self): ...
    @property
    def profiles(self): ...
